// node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js
var AzureKeyCredential = class {
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = key;
  }
  /**
   * The value of the key to be used in authentication
   */
  get key() {
    return this._key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  update(newKey) {
    this._key = newKey;
  }
};

// node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}

// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js
var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
var HttpPipeline = class {
  constructor(policies) {
    var _a2;
    this._policies = [];
    this._policies = (_a2 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a2 !== void 0 ? _a2 : [];
    this._orderedPolicies = void 0;
  }
  addPolicy(policy, options = {}) {
    if (options.phase && options.afterPhase) {
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    }
    if (options.phase && !ValidPhaseNames.has(options.phase)) {
      throw new Error(`Invalid phase name: ${options.phase}`);
    }
    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
    }
    this._policies.push({
      policy,
      options
    });
    this._orderedPolicies = void 0;
  }
  removePolicy(options) {
    const removedPolicies = [];
    this._policies = this._policies.filter((policyDescriptor) => {
      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
        removedPolicies.push(policyDescriptor.policy);
        return false;
      } else {
        return true;
      }
    });
    this._orderedPolicies = void 0;
    return removedPolicies;
  }
  sendRequest(httpClient, request) {
    const policies = this.getOrderedPolicies();
    const pipeline = policies.reduceRight((next, policy) => {
      return (req) => {
        return policy.sendRequest(req, next);
      };
    }, (req) => httpClient.sendRequest(req));
    return pipeline(request);
  }
  getOrderedPolicies() {
    if (!this._orderedPolicies) {
      this._orderedPolicies = this.orderPolicies();
    }
    return this._orderedPolicies;
  }
  clone() {
    return new HttpPipeline(this._policies);
  }
  static create() {
    return new HttpPipeline();
  }
  orderPolicies() {
    const result = [];
    const policyMap = /* @__PURE__ */ new Map();
    function createPhase(name) {
      return {
        name,
        policies: /* @__PURE__ */ new Set(),
        hasRun: false,
        hasAfterPolicies: false
      };
    }
    const serializePhase = createPhase("Serialize");
    const noPhase = createPhase("None");
    const deserializePhase = createPhase("Deserialize");
    const retryPhase = createPhase("Retry");
    const signPhase = createPhase("Sign");
    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
    function getPhase(phase) {
      if (phase === "Retry") {
        return retryPhase;
      } else if (phase === "Serialize") {
        return serializePhase;
      } else if (phase === "Deserialize") {
        return deserializePhase;
      } else if (phase === "Sign") {
        return signPhase;
      } else {
        return noPhase;
      }
    }
    for (const descriptor of this._policies) {
      const policy = descriptor.policy;
      const options = descriptor.options;
      const policyName = policy.name;
      if (policyMap.has(policyName)) {
        throw new Error("Duplicate policy names not allowed in pipeline");
      }
      const node = {
        policy,
        dependsOn: /* @__PURE__ */ new Set(),
        dependants: /* @__PURE__ */ new Set()
      };
      if (options.afterPhase) {
        node.afterPhase = getPhase(options.afterPhase);
        node.afterPhase.hasAfterPolicies = true;
      }
      policyMap.set(policyName, node);
      const phase = getPhase(options.phase);
      phase.policies.add(node);
    }
    for (const descriptor of this._policies) {
      const { policy, options } = descriptor;
      const policyName = policy.name;
      const node = policyMap.get(policyName);
      if (!node) {
        throw new Error(`Missing node for policy ${policyName}`);
      }
      if (options.afterPolicies) {
        for (const afterPolicyName of options.afterPolicies) {
          const afterNode = policyMap.get(afterPolicyName);
          if (afterNode) {
            node.dependsOn.add(afterNode);
            afterNode.dependants.add(node);
          }
        }
      }
      if (options.beforePolicies) {
        for (const beforePolicyName of options.beforePolicies) {
          const beforeNode = policyMap.get(beforePolicyName);
          if (beforeNode) {
            beforeNode.dependsOn.add(node);
            node.dependants.add(beforeNode);
          }
        }
      }
    }
    function walkPhase(phase) {
      phase.hasRun = true;
      for (const node of phase.policies) {
        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
          continue;
        }
        if (node.dependsOn.size === 0) {
          result.push(node.policy);
          for (const dependant of node.dependants) {
            dependant.dependsOn.delete(node);
          }
          policyMap.delete(node.policy.name);
          phase.policies.delete(node);
        }
      }
    }
    function walkPhases() {
      for (const phase of orderedPhases) {
        walkPhase(phase);
        if (phase.policies.size > 0 && phase !== noPhase) {
          if (!noPhase.hasRun) {
            walkPhase(noPhase);
          }
          return;
        }
        if (phase.hasAfterPolicies) {
          walkPhase(noPhase);
        }
      }
    }
    let iteration = 0;
    while (policyMap.size > 0) {
      iteration++;
      const initialResultLength = result.length;
      walkPhases();
      if (result.length <= initialResultLength && iteration > 1) {
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
      }
    }
    return result;
  }
};
function createEmptyPipeline() {
  return HttpPipeline.create();
}

// node_modules/@azure/logger/dist-esm/src/log.browser.js
function log(...args) {
  if (args.length > 0) {
    const firstArg = String(args[0]);
    if (firstArg.includes(":error")) {
      console.error(...args);
    } else if (firstArg.includes(":warning")) {
      console.warn(...args);
    } else if (firstArg.includes(":info")) {
      console.info(...args);
    } else if (firstArg.includes(":verbose")) {
      console.debug(...args);
    } else {
      console.debug(...args);
    }
  }
}

// node_modules/@azure/logger/dist-esm/src/debug.js
var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];
if (debugEnvVariable) {
  enable(debugEnvVariable);
}
var debugObj = Object.assign((namespace) => {
  return createDebugger(namespace);
}, {
  enable,
  enabled,
  disable,
  log
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debug_default = debugObj;

// node_modules/@azure/logger/dist-esm/src/index.js
var registeredLoggers = /* @__PURE__ */ new Set();
var logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
var azureLogLevel;
var AzureLogger = debug_default("azure");
AzureLogger.log = (...args) => {
  debug_default.log(...args);
};
var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
if (logLevelFromEnv) {
  if (isAzureLogLevel(logLevelFromEnv)) {
    setLogLevel(logLevelFromEnv);
  } else {
    console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
  }
}
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger3 of registeredLoggers) {
    if (shouldEnable(logger3)) {
      enabledNamespaces2.push(logger3.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger3 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger3);
  if (shouldEnable(logger3)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger3.namespace);
  }
  registeredLoggers.add(logger3);
  return logger3;
}
function shouldEnable(logger3) {
  return Boolean(azureLogLevel && levelMap[logger3.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js
var logger = createClientLogger("core-rest-pipeline");

// node_modules/@azure/core-util/dist-esm/src/isNode.browser.js
var isNode = false;

// node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
};

// node_modules/@azure/core-util/dist-esm/src/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}

// node_modules/@azure/core-util/dist-esm/src/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}

// node_modules/@azure/core-util/dist-esm/src/error.js
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js
function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const randomNumber = Math.floor(Math.random() * 16);
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += randomNumber & 3 | 8;
    } else {
      uuid += randomNumber.toString(16);
    }
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}

// node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js
var _a;
var uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : generateUUID;
function randomUUID() {
  return uuidFunction();
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
];
var defaultAllowedQueryParameters = ["api-version"];
var Sanitizer = class {
  constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
  }
  sanitize(obj) {
    const seen = /* @__PURE__ */ new Set();
    return JSON.stringify(obj, (key, value) => {
      if (value instanceof Error) {
        return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
      }
      if (key === "headers") {
        return this.sanitizeHeaders(value);
      } else if (key === "url") {
        return this.sanitizeUrl(value);
      } else if (key === "query") {
        return this.sanitizeQuery(value);
      } else if (key === "body") {
        return void 0;
      } else if (key === "response") {
        return void 0;
      } else if (key === "operationSpec") {
        return void 0;
      } else if (Array.isArray(value) || isObject(value)) {
        if (seen.has(value)) {
          return "[Circular]";
        }
        seen.add(value);
      }
      return value;
    }, 2);
  }
  sanitizeHeaders(obj) {
    const sanitized = {};
    for (const key of Object.keys(obj)) {
      if (this.allowedHeaderNames.has(key.toLowerCase())) {
        sanitized[key] = obj[key];
      } else {
        sanitized[key] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeQuery(value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const sanitized = {};
    for (const k of Object.keys(value)) {
      if (this.allowedQueryParameters.has(k.toLowerCase())) {
        sanitized[k] = value[k];
      } else {
        sanitized[k] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeUrl(value) {
    if (typeof value !== "string" || value === null) {
      return value;
    }
    const url = new URL(value);
    if (!url.search) {
      return value;
    }
    for (const [key] of url.searchParams) {
      if (!this.allowedQueryParameters.has(key.toLowerCase())) {
        url.searchParams.set(key, RedactedString);
      }
    }
    return url.toString();
  }
};

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js
var logPolicyName = "logPolicy";
function logPolicy(options = {}) {
  var _a2;
  const logger3 = (_a2 = options.logger) !== null && _a2 !== void 0 ? _a2 : logger.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request, next) {
      if (!logger3.enabled) {
        return next(request);
      }
      logger3(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      logger3(`Response status code: ${response.status}`);
      logger3(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js
var redirectPolicyName = "redirectPolicy";
var allowedRedirect = ["GET", "HEAD"];
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request.url);
    request.url = url.toString();
    if (status === 303) {
      request.method = "GET";
      request.headers.delete("Content-Length");
      delete request.body;
    }
    request.headers.delete("Authorization");
    const res = await next(request);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js
function getHeaderName() {
  return "x-ms-useragent";
}
function setPlatformSpecificData(map) {
  var _a2, _b, _c;
  const localNavigator = globalThis.navigator;
  map.set("OS", ((_c = (_b = (_a2 = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a2 === void 0 ? void 0 : _a2.platform) !== null && _b !== void 0 ? _b : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c !== void 0 ? _c : "unknown").replace(" ", ""));
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js
var SDK_VERSION = "1.11.0";
var DEFAULT_RETRY_POLICY_COUNT = 3;

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
  setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js
var UserAgentHeaderName = getUserAgentHeaderName();
var userAgentPolicyName = "userAgentPolicy";
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(UserAgentHeaderName)) {
        request.headers.set(UserAgentHeaderName, userAgentValue);
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js
var NotSupported = new Error("decompressResponsePolicy is not supported in browser environment");
function decompressResponsePolicy() {
  throw NotSupported;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js
var StandardAbortMessage = "The operation was aborted.";
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js
var RetryAfterHeader = "Retry-After";
var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (e) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js
var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
function exponentialRetryStrategy(options = {}) {
  var _a2, _b;
  const retryInterval = (_a2 = options.retryDelayInMs) !== null && _a2 !== void 0 ? _a2 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT";
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js
var retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
var retryPolicyName = "retryPolicy";
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger3 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request, next) {
      var _a2, _b;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger3.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
            response = await next(request);
            logger3.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
          } catch (e) {
            logger3.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a2 = request.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            logger3.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError();
            throw abortError;
          }
          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
            logger3.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger3.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger3.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger3.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js
var defaultRetryPolicyName = "defaultRetryPolicy";
function defaultRetryPolicy(options = {}) {
  var _a2;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a2 = options.maxRetries) !== null && _a2 !== void 0 ? _a2 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.browser.js
var formDataPolicyName = "formDataPolicy";
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request, next) {
      if (request.formData) {
        const formData = request.formData;
        const requestForm = new FormData();
        for (const formKey of Object.keys(formData)) {
          const formValue = formData[formKey];
          if (Array.isArray(formValue)) {
            for (const subValue of formValue) {
              requestForm.append(formKey, subValue);
            }
          } else {
            requestForm.append(formKey, formValue);
          }
        }
        request.body = requestForm;
        request.formData = void 0;
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = new URLSearchParams(requestForm).toString();
        } else if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
          request.headers.delete("Content-Type");
        }
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js
var NotSupported2 = new Error("proxyPolicy is not supported in browser environment");
function proxyPolicy() {
  throw NotSupported2;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js
var setClientRequestIdPolicyName = "setClientRequestIdPolicy";
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(requestIdHeaderName)) {
        request.headers.set(requestIdHeaderName, request.requestId);
      }
      return next(request);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js
var tlsPolicyName = "tlsPolicy";
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}

// node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js
var knownContextKeys = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
function createTracingContext(options = {}) {
  let context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
var TracingContextImpl = class {
  constructor(initialContext) {
    this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
  }
  setValue(key, value) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.set(key, value);
    return newContext;
  }
  getValue(key) {
    return this._contextMap.get(key);
  }
  deleteValue(key) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.delete(key);
    return newContext;
  }
};

// node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
var instrumenterImplementation;
function getInstrumenter() {
  if (!instrumenterImplementation) {
    instrumenterImplementation = createDefaultInstrumenter();
  }
  return instrumenterImplementation;
}

// node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name, operationOptions, spanOptions) {
    var _a2;
    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a2 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js
var custom = {};

// node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js
var errorSanitizer = new Sanitizer();
var RestError = class extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = "RestError";
    this.code = options.code;
    this.statusCode = options.statusCode;
    this.request = options.request;
    this.response = options.response;
    Object.setPrototypeOf(this, RestError.prototype);
  }
  /**
   * Logging method for util.inspect in Node
   */
  [custom]() {
    return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
  }
};
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
RestError.PARSE_ERROR = "PARSE_ERROR";
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js
var tracingPolicyName = "tracingPolicy";
function tracingPolicy(options = {}) {
  const userAgent = getUserAgentValue(options.userAgentPrefix);
  const tracingClient = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request, next) {
      var _a2, _b;
      if (!tracingClient || !((_a2 = request.tracingOptions) === null || _a2 === void 0 ? void 0 : _a2.tracingContext)) {
        return next(request);
      }
      const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
      if (!span || !tracingContext) {
        return next(request);
      }
      try {
        const response = await tracingClient.withContext(tracingContext, next, request);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION
    });
  } catch (e) {
    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient, request, userAgent) {
  try {
    const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
      spanKind: "client",
      spanAttributes: {
        "http.method": request.method,
        "http.url": request.url,
        requestId: request.requestId
      }
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js
function createPipelineFromOptions(options) {
  const pipeline = createEmptyPipeline();
  if (isNode) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy());
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy());
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
  if (isNode) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js
function normalizeName(name) {
  return name.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
var HttpHeadersImpl = class {
  constructor(rawHeaders) {
    this._headersMap = /* @__PURE__ */ new Map();
    if (rawHeaders) {
      for (const headerName of Object.keys(rawHeaders)) {
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  set(name, value) {
    this._headersMap.set(normalizeName(name), { name, value: String(value) });
  }
  /**
   * Get the header value for the provided header name, or undefined if no header exists in this
   * collection with the provided name.
   * @param name - The name of the header. This value is case-insensitive.
   */
  get(name) {
    var _a2;
    return (_a2 = this._headersMap.get(normalizeName(name))) === null || _a2 === void 0 ? void 0 : _a2.value;
  }
  /**
   * Get whether or not this header collection contains a header entry for the provided header name.
   * @param name - The name of the header to set. This value is case-insensitive.
   */
  has(name) {
    return this._headersMap.has(normalizeName(name));
  }
  /**
   * Remove the header with the provided headerName.
   * @param name - The name of the header to remove.
   */
  delete(name) {
    this._headersMap.delete(normalizeName(name));
  }
  /**
   * Get the JSON object representation of this HTTP header collection.
   */
  toJSON(options = {}) {
    const result = {};
    if (options.preserveCase) {
      for (const entry of this._headersMap.values()) {
        result[entry.name] = entry.value;
      }
    } else {
      for (const [normalizedName, entry] of this._headersMap) {
        result[normalizedName] = entry.value;
      }
    }
    return result;
  }
  /**
   * Get the string representation of this HTTP header collection.
   */
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: true }));
  }
  /**
   * Iterate over tuples of header [name, value] pairs.
   */
  [Symbol.iterator]() {
    return headerIterator(this._headersMap);
  }
};
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js
function isNodeReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isReadableStream(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}
function isBlob(body) {
  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
var FetchHttpClient = class {
  /**
   * Makes a request over an underlying transport layer and returns the response.
   * @param request - The request to be made.
   */
  async sendRequest(request) {
    const url = new URL(request.url);
    const isInsecure = url.protocol !== "https:";
    if (isInsecure && !request.allowInsecureConnection) {
      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
    }
    if (request.proxySettings) {
      throw new Error("HTTP proxy is not supported in browser environment");
    }
    try {
      return await makeRequest(request);
    } catch (e) {
      throw getError(e, request);
    }
  }
};
async function makeRequest(request) {
  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
  try {
    const headers = buildFetchHeaders(request.headers);
    const requestBody = buildRequestBody(request);
    const response = await fetch(request.url, {
      body: requestBody,
      method: request.method,
      headers,
      signal: abortController.signal,
      credentials: request.withCredentials ? "include" : "same-origin",
      cache: "no-store"
    });
    if (isBlob(request.body) && request.onUploadProgress) {
      request.onUploadProgress({ loadedBytes: request.body.size });
    }
    return buildPipelineResponse(response, request);
  } finally {
    if (abortControllerCleanup) {
      abortControllerCleanup();
    }
  }
}
async function buildPipelineResponse(httpResponse, request) {
  var _a2, _b;
  const headers = buildPipelineHeaders(httpResponse);
  const response = {
    request,
    headers,
    status: httpResponse.status
  };
  const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a2 = request.streamResponseStatusCodes) === null || _a2 === void 0 ? void 0 : _a2.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))
  ) {
    if (request.enableBrowserStreams) {
      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : void 0;
    } else {
      const responseStream = new Response(bodyStream);
      response.blobBody = responseStream.blob();
    }
  } else {
    const responseStream = new Response(bodyStream);
    response.bodyAsText = await responseStream.text();
  }
  return response;
}
function setupAbortSignal(request) {
  const abortController = new AbortController();
  let abortControllerCleanup;
  let abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new AbortError("The operation was aborted.");
    }
    abortListener = (event) => {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = () => {
      var _a2;
      if (abortListener) {
        (_a2 = request.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", abortListener);
      }
    };
  }
  if (request.timeout > 0) {
    setTimeout(() => {
      abortController.abort();
    }, request.timeout);
  }
  return { abortController, abortControllerCleanup };
}
function getError(e, request) {
  var _a2;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new RestError(`Error sending request: ${e.message}`, {
      code: (_a2 = e === null || e === void 0 ? void 0 : e.code) !== null && _a2 !== void 0 ? _a2 : RestError.REQUEST_SEND_ERROR,
      request
    });
  }
}
function buildFetchHeaders(pipelineHeaders) {
  const headers = new Headers();
  for (const [name, value] of pipelineHeaders) {
    headers.append(name, value);
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  const responseHeaders = createHttpHeaders();
  for (const [name, value] of httpResponse.headers) {
    responseHeaders.set(name, value);
  }
  return responseHeaders;
}
function buildRequestBody(request) {
  const body = typeof request.body === "function" ? request.body() : request.body;
  if (isNodeReadableStream(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;
}
function buildBodyStream(readableStream, onProgress) {
  let loadedBytes = 0;
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      }
    }));
  } else {
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        var _a2;
        const { done, value } = await reader.read();
        if (done || !value) {
          controller.close();
          reader.releaseLock();
          return;
        }
        loadedBytes += (_a2 = value === null || value === void 0 ? void 0 : value.length) !== null && _a2 !== void 0 ? _a2 : 0;
        controller.enqueue(value);
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      }
    });
  }
}
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== void 0 && self.TransformStream !== void 0;
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js
function createDefaultHttpClient() {
  return createFetchHttpClient();
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js
var PipelineRequestImpl = class {
  constructor(options) {
    var _a2, _b, _c, _d, _e, _f, _g;
    this.url = options.url;
    this.body = options.body;
    this.headers = (_a2 = options.headers) !== null && _a2 !== void 0 ? _a2 : createHttpHeaders();
    this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
    this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
    this.formData = options.formData;
    this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
    this.proxySettings = options.proxySettings;
    this.streamResponseStatusCodes = options.streamResponseStatusCodes;
    this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
    this.abortSignal = options.abortSignal;
    this.tracingOptions = options.tracingOptions;
    this.onUploadProgress = options.onUploadProgress;
    this.onDownloadProgress = options.onDownloadProgress;
    this.requestId = options.requestId || randomUUID();
    this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
    this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
  }
};
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js
var DEFAULT_CYCLER_OPTIONS = {
  forcedRefreshWindowInMs: 1e3,
  retryIntervalInMs: 3e3,
  refreshWindowInMs: 1e3 * 60 * 2
  // Start refreshing 2m before expiry
};
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a2) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a2;
      return !cycler.isRefreshing && ((_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a2;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a2 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a2 !== void 0 ? _a2 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
    if (mustRefresh)
      return refresh(scopes, tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}

// node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js
var bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request } = options;
  const getTokenOptions = {
    abortSignal: request.abortSignal,
    tracingOptions: request.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger3 = options.logger || logger;
  const callbacks = Object.assign({ authorizeRequest: (_a2 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a2 !== void 0 ? _a2 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request,
        getAccessToken,
        logger: logger3
      });
      let response;
      let error;
      try {
        response = await next(request);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          response,
          getAccessToken,
          logger: logger3
        });
        if (shouldSendRequest) {
          return next(request);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/apiVersionPolicy.js
var apiVersionPolicyName = "ApiVersionPolicy";
function apiVersionPolicy(options) {
  return {
    name: apiVersionPolicyName,
    sendRequest: (req, next) => {
      const url = new URL(req.url);
      if (!url.searchParams.get("api-version") && options.apiVersion) {
        req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
      }
      return next(req);
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/keyCredentialAuthenticationPolicy.js
var keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
function keyCredentialAuthenticationPolicy(credential, apiKeyHeaderName) {
  return {
    name: keyCredentialAuthenticationPolicyName,
    async sendRequest(request, next) {
      request.headers.set(apiKeyHeaderName, credential.key);
      return next(request);
    }
  };
}

// node_modules/@azure-rest/core-client/dist-esm/src/clientHelpers.js
var cachedHttpClient;
function createDefaultPipeline(baseUrl, credential, options = {}) {
  var _a2, _b, _c, _d;
  const pipeline = createPipelineFromOptions(options);
  pipeline.addPolicy(apiVersionPolicy(options));
  if (credential) {
    if (isTokenCredential(credential)) {
      const tokenPolicy = bearerTokenAuthenticationPolicy({
        credential,
        scopes: (_b = (_a2 = options.credentials) === null || _a2 === void 0 ? void 0 : _a2.scopes) !== null && _b !== void 0 ? _b : `${baseUrl}/.default`
      });
      pipeline.addPolicy(tokenPolicy);
    } else if (isKeyCredential(credential)) {
      if (!((_c = options.credentials) === null || _c === void 0 ? void 0 : _c.apiKeyHeaderName)) {
        throw new Error(`Missing API Key Header Name`);
      }
      const keyPolicy = keyCredentialAuthenticationPolicy(credential, (_d = options.credentials) === null || _d === void 0 ? void 0 : _d.apiKeyHeaderName);
      pipeline.addPolicy(keyPolicy);
    }
  }
  return pipeline;
}
function isKeyCredential(credential) {
  return credential.key !== void 0;
}
function getCachedDefaultHttpsClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@azure-rest/core-client/dist-esm/src/helpers/isReadableStream.browser.js
function isReadableStream2(body) {
  return Boolean(body && typeof body.getReader === "function" && typeof body.tee === "function");
}

// node_modules/@azure-rest/core-client/dist-esm/src/helpers/getBinaryBody.js
function binaryArrayToString(content) {
  let decodedBody = "";
  for (const element of content) {
    decodedBody += String.fromCharCode(element);
  }
  return decodedBody;
}

// node_modules/@azure-rest/core-client/dist-esm/src/sendRequest.js
async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
  const request = buildPipelineRequest(method, url, options);
  const response = await pipeline.sendRequest(httpClient, request);
  const rawHeaders = response.headers.toJSON();
  const parsedBody = getResponseBody(response);
  return {
    request,
    headers: rawHeaders,
    status: `${response.status}`,
    body: parsedBody
  };
}
async function sendRequestAsStream(method, url, pipeline, options = {}, customHttpClient) {
  var _a2;
  const httpClient = customHttpClient !== null && customHttpClient !== void 0 ? customHttpClient : getCachedDefaultHttpsClient();
  const request = buildPipelineRequest(method, url, Object.assign(Object.assign({}, options), { responseAsStream: true }));
  const response = await pipeline.sendRequest(httpClient, request);
  const rawHeaders = response.headers.toJSON();
  const parsedBody = (_a2 = response.browserStreamBody) !== null && _a2 !== void 0 ? _a2 : response.readableStreamBody;
  return {
    request,
    headers: rawHeaders,
    status: `${response.status}`,
    body: parsedBody
  };
}
function getContentType(body) {
  if (ArrayBuffer.isView(body)) {
    return "application/octet-stream";
  }
  return "application/json; charset=UTF-8";
}
function buildPipelineRequest(method, url, options = {}) {
  var _a2, _b;
  const { body, formData } = getRequestBody(options.body, options.contentType);
  const hasContent = body !== void 0 || formData !== void 0;
  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), { accept: (_a2 = options.accept) !== null && _a2 !== void 0 ? _a2 : "application/json" }), hasContent && {
    "content-type": (_b = options.contentType) !== null && _b !== void 0 ? _b : getContentType(options.body)
  }));
  return createPipelineRequest({
    url,
    method,
    body,
    formData,
    headers,
    allowInsecureConnection: options.allowInsecureConnection,
    enableBrowserStreams: true,
    streamResponseStatusCodes: options.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
  });
}
function getRequestBody(body, contentType = "") {
  if (body === void 0) {
    return { body: void 0 };
  }
  if (isReadableStream2(body)) {
    return { body };
  }
  if (!contentType && typeof body === "string") {
    return { body };
  }
  const firstType = contentType.split(";")[0];
  if (firstType === "application/json") {
    return { body: JSON.stringify(body) };
  }
  if (ArrayBuffer.isView(body)) {
    if (body instanceof Uint8Array) {
      return { body: binaryArrayToString(body) };
    } else {
      return { body: JSON.stringify(body) };
    }
  }
  switch (firstType) {
    case "multipart/form-data":
      return isFormData(body) ? { formData: processFormData(body) } : { body: JSON.stringify(body) };
    case "text/plain":
      return { body: String(body) };
    default:
      if (typeof body === "string") {
        return { body };
      }
      return { body: JSON.stringify(body) };
  }
}
function isFormData(body) {
  return body instanceof Object && Object.keys(body).length > 0;
}
function processFormData(formData) {
  if (!formData) {
    return formData;
  }
  const processedFormData = {};
  for (const element in formData) {
    const item = formData[element];
    if (item instanceof Uint8Array) {
      processedFormData[element] = binaryArrayToString(item);
    } else {
      processedFormData[element] = item;
    }
  }
  return processedFormData;
}
function getResponseBody(response) {
  var _a2, _b;
  const contentType = (_a2 = response.headers.get("content-type")) !== null && _a2 !== void 0 ? _a2 : "";
  const firstType = contentType.split(";")[0];
  const bodyToParse = (_b = response.bodyAsText) !== null && _b !== void 0 ? _b : "";
  if (firstType === "text/plain") {
    return String(bodyToParse);
  }
  try {
    return bodyToParse ? JSON.parse(bodyToParse) : void 0;
  } catch (error) {
    if (firstType === "application/json") {
      throw createParseError(response, error);
    }
    return String(bodyToParse);
  }
}
function createParseError(response, err) {
  var _a2;
  const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
  const errCode = (_a2 = err.code) !== null && _a2 !== void 0 ? _a2 : RestError.PARSE_ERROR;
  return new RestError(msg, {
    code: errCode,
    statusCode: response.status,
    request: response.request,
    response
  });
}

// node_modules/@azure-rest/core-client/dist-esm/src/urlHelpers.js
function buildRequestUrl(baseUrl, routePath, pathParameters, options = {}) {
  if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
    return routePath;
  }
  baseUrl = buildBaseUrl(baseUrl, options);
  routePath = buildRoutePath(routePath, pathParameters, options);
  const requestUrl = appendQueryParams(`${baseUrl}/${routePath}`, options);
  const url = new URL(requestUrl);
  return url.toString().replace(/([^:]\/)\/+/g, "$1");
}
function appendQueryParams(url, options = {}) {
  if (!options.queryParameters) {
    return url;
  }
  let parsedUrl = new URL(url);
  const queryParams = options.queryParameters;
  for (const key of Object.keys(queryParams)) {
    const param = queryParams[key];
    if (param === void 0 || param === null) {
      continue;
    }
    if (!param.toString || typeof param.toString !== "function") {
      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
    }
    const value = param.toISOString !== void 0 ? param.toISOString() : param.toString();
    parsedUrl.searchParams.append(key, value);
  }
  if (options.skipUrlEncoding) {
    parsedUrl = skipQueryParameterEncoding(parsedUrl);
  }
  return parsedUrl.toString();
}
function skipQueryParameterEncoding(url) {
  if (!url) {
    return url;
  }
  const searchPieces = [];
  for (const [name, value] of url.searchParams) {
    searchPieces.push(`${name}=${value}`);
  }
  url.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return url;
}
function buildBaseUrl(baseUrl, options) {
  var _a2;
  if (!options.pathParameters) {
    return baseUrl;
  }
  const pathParams = options.pathParameters;
  for (const [key, param] of Object.entries(pathParams)) {
    if (param === void 0 || param === null) {
      throw new Error(`Path parameters ${key} must not be undefined or null`);
    }
    if (!param.toString || typeof param.toString !== "function") {
      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
    }
    let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
    if (!options.skipUrlEncoding) {
      value = encodeURIComponent(param);
    }
    baseUrl = (_a2 = replaceAll(baseUrl, `{${key}}`, value)) !== null && _a2 !== void 0 ? _a2 : "";
  }
  return baseUrl;
}
function buildRoutePath(routePath, pathParameters, options = {}) {
  for (const pathParam of pathParameters) {
    let value = pathParam;
    if (!options.skipUrlEncoding) {
      value = encodeURIComponent(pathParam);
    }
    routePath = routePath.replace(/\{\w+\}/, value);
  }
  return routePath;
}
function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}

// node_modules/@azure-rest/core-client/dist-esm/src/getClient.js
function getClient(baseUrl, credentialsOrPipelineOptions, clientOptions = {}) {
  var _a2;
  let credentials;
  if (credentialsOrPipelineOptions) {
    if (isCredential(credentialsOrPipelineOptions)) {
      credentials = credentialsOrPipelineOptions;
    } else {
      clientOptions = credentialsOrPipelineOptions !== null && credentialsOrPipelineOptions !== void 0 ? credentialsOrPipelineOptions : {};
    }
  }
  const pipeline = createDefaultPipeline(baseUrl, credentials, clientOptions);
  if ((_a2 = clientOptions.additionalPolicies) === null || _a2 === void 0 ? void 0 : _a2.length) {
    for (const { policy, position } of clientOptions.additionalPolicies) {
      const afterPhase = position === "perRetry" ? "Sign" : void 0;
      pipeline.addPolicy(policy, {
        afterPhase
      });
    }
  }
  const { allowInsecureConnection, httpClient } = clientOptions;
  const client = (path, ...args) => {
    const getUrl = (requestOptions) => buildRequestUrl(baseUrl, path, args, Object.assign({ allowInsecureConnection }, requestOptions));
    return {
      get: (requestOptions = {}) => {
        return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      post: (requestOptions = {}) => {
        return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      put: (requestOptions = {}) => {
        return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      patch: (requestOptions = {}) => {
        return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      delete: (requestOptions = {}) => {
        return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      head: (requestOptions = {}) => {
        return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      options: (requestOptions = {}) => {
        return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      },
      trace: (requestOptions = {}) => {
        return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
      }
    };
  };
  return {
    path: client,
    pathUnchecked: client,
    pipeline
  };
}
function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
  return {
    then: function(onFulfilled, onrejected) {
      return sendRequest(method, url, pipeline, Object.assign({ allowInsecureConnection }, options), httpClient).then(onFulfilled, onrejected);
    },
    async asBrowserStream() {
      return sendRequestAsStream(method, url, pipeline, Object.assign({ allowInsecureConnection }, options), httpClient);
    },
    async asNodeStream() {
      return sendRequestAsStream(method, url, pipeline, Object.assign({ allowInsecureConnection }, options), httpClient);
    }
  };
}
function isCredential(param) {
  if (param.key !== void 0 || isTokenCredential(param)) {
    return true;
  }
  return false;
}

// node_modules/@azure/openai/dist-esm/src/logger.js
var logger2 = createClientLogger("openai");

// node_modules/@azure/openai/dist-esm/src/rest/openAIClient.js
function createClient(endpoint, credentials, options = {}) {
  var _a2, _b, _c, _d;
  const baseUrl = (_a2 = options.baseUrl) !== null && _a2 !== void 0 ? _a2 : `${endpoint}/openai`;
  options.apiVersion = (_b = options.apiVersion) !== null && _b !== void 0 ? _b : "2023-03-15-preview";
  options = Object.assign({ credentials: {
    scopes: ["https://cognitiveservices.azure.com/.default"],
    apiKeyHeaderName: "api-key"
  } }, options);
  const userAgentInfo = `azsdk-js-openai-rest/1.0.0-beta.2`;
  const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}` : `${userAgentInfo}`;
  options = Object.assign(Object.assign({}, options), { userAgentOptions: {
    userAgentPrefix
  }, loggingOptions: {
    logger: (_d = (_c = options.loggingOptions) === null || _c === void 0 ? void 0 : _c.logger) !== null && _d !== void 0 ? _d : logger2.info
  } });
  const client = getClient(baseUrl, credentials, options);
  return client;
}

// node_modules/@azure/openai/dist-esm/src/rest/isUnexpected.js
var responseMap = {
  "POST /deployments/{deploymentId}/embeddings": ["200"],
  "POST /deployments/{deploymentId}/completions": ["200"],
  "POST /deployments/{deploymentId}/chat/completions": ["200"]
};
function isUnexpected(response) {
  const lroOriginal = response.headers["x-ms-original-url"];
  const url = new URL(lroOriginal !== null && lroOriginal !== void 0 ? lroOriginal : response.request.url);
  const method = response.request.method;
  let pathDetails = responseMap[`${method} ${url.pathname}`];
  if (!pathDetails) {
    pathDetails = getParametrizedPathSuccess(method, url.pathname);
  }
  return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path) {
  var _a2, _b, _c, _d;
  const pathParts = path.split("/");
  let matchedLen = -1, matchedValue = [];
  for (const [key, value] of Object.entries(responseMap)) {
    if (!key.startsWith(method)) {
      continue;
    }
    const candidatePath = getPathFromMapKey(key);
    const candidateParts = candidatePath.split("/");
    let found = true;
    for (let i = candidateParts.length - 1, j = pathParts.length - 1; i >= 1 && j >= 1; i--, j--) {
      if (((_a2 = candidateParts[i]) === null || _a2 === void 0 ? void 0 : _a2.startsWith("{")) && ((_b = candidateParts[i]) === null || _b === void 0 ? void 0 : _b.indexOf("}")) !== -1) {
        const start = candidateParts[i].indexOf("}") + 1, end = (_c = candidateParts[i]) === null || _c === void 0 ? void 0 : _c.length;
        const isMatched = new RegExp(`${(_d = candidateParts[i]) === null || _d === void 0 ? void 0 : _d.slice(start, end)}`).test(pathParts[j] || "");
        if (!isMatched) {
          found = false;
          break;
        }
        continue;
      }
      if (candidateParts[i] !== pathParts[j]) {
        found = false;
        break;
      }
    }
    if (found && candidatePath.length > matchedLen) {
      matchedLen = candidatePath.length;
      matchedValue = value;
    }
  }
  return matchedValue;
}
function getPathFromMapKey(mapKey) {
  const pathStart = mapKey.indexOf("/");
  return mapKey.slice(pathStart);
}

// node_modules/@azure/openai/dist-esm/src/rest/index.js
var rest_default = createClient;

// node_modules/@azure/openai/dist-esm/src/api/OpenAIContext.js
function createOpenAI(endpoint, credential, options = {}) {
  const baseUrl = endpoint;
  const clientContext = rest_default(baseUrl, credential, options);
  return clientContext;
}

// node_modules/@azure/openai/dist-esm/src/api/operations.js
function _getEmbeddingsSend(context, input, deploymentId, options = { requestOptions: {} }) {
  var _a2, _b, _c;
  return context.path("/deployments/{deploymentId}/embeddings", deploymentId).post({
    allowInsecureConnection: (_a2 = options.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.allowInsecureConnection,
    skipUrlEncoding: (_b = options.requestOptions) === null || _b === void 0 ? void 0 : _b.skipUrlEncoding,
    headers: Object.assign({}, (_c = options.requestOptions) === null || _c === void 0 ? void 0 : _c.headers),
    body: { user: options === null || options === void 0 ? void 0 : options.user, model: options === null || options === void 0 ? void 0 : options.model, input }
  });
}
async function _getEmbeddingsDeserialize(result) {
  var _a2;
  if (isUnexpected(result)) {
    throw result.body;
  }
  return {
    data: ((_a2 = result.body["data"]) !== null && _a2 !== void 0 ? _a2 : []).map((p) => ({
      embedding: p["embedding"],
      index: p["index"]
    })),
    usage: {
      promptTokens: result.body.usage["prompt_tokens"],
      totalTokens: result.body.usage["total_tokens"]
    }
  };
}
async function getEmbeddings(context, input, deploymentId, options = { requestOptions: {} }) {
  const result = await _getEmbeddingsSend(context, input, deploymentId, options);
  return _getEmbeddingsDeserialize(result);
}
function _getCompletionsSend(context, prompt, deploymentId, options = { requestOptions: {} }) {
  var _a2, _b, _c;
  return context.path("/deployments/{deploymentId}/completions", deploymentId).post({
    allowInsecureConnection: (_a2 = options.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.allowInsecureConnection,
    skipUrlEncoding: (_b = options.requestOptions) === null || _b === void 0 ? void 0 : _b.skipUrlEncoding,
    headers: Object.assign({}, (_c = options.requestOptions) === null || _c === void 0 ? void 0 : _c.headers),
    body: {
      prompt,
      max_tokens: options === null || options === void 0 ? void 0 : options.maxTokens,
      temperature: options === null || options === void 0 ? void 0 : options.temperature,
      top_p: options === null || options === void 0 ? void 0 : options.topP,
      logit_bias: options === null || options === void 0 ? void 0 : options.logitBias,
      user: options === null || options === void 0 ? void 0 : options.user,
      n: options === null || options === void 0 ? void 0 : options.n,
      logprobs: options === null || options === void 0 ? void 0 : options.logprobs,
      echo: options === null || options === void 0 ? void 0 : options.echo,
      stop: options === null || options === void 0 ? void 0 : options.stop,
      presence_penalty: options === null || options === void 0 ? void 0 : options.presencePenalty,
      frequency_penalty: options === null || options === void 0 ? void 0 : options.frequencyPenalty,
      best_of: options === null || options === void 0 ? void 0 : options.bestOf,
      stream: options === null || options === void 0 ? void 0 : options.stream,
      model: options === null || options === void 0 ? void 0 : options.model
    }
  });
}
async function _getCompletionsDeserialize(result) {
  var _a2;
  if (isUnexpected(result)) {
    throw result.body;
  }
  return {
    id: result.body["id"],
    created: result.body["created"],
    choices: ((_a2 = result.body["choices"]) !== null && _a2 !== void 0 ? _a2 : []).map((p) => ({
      text: p["text"],
      index: p["index"],
      logprobs: p.logprobs === null ? null : {
        tokens: p.logprobs["tokens"],
        tokenLogprobs: p.logprobs["token_logprobs"],
        topLogprobs: p.logprobs["top_logprobs"],
        textOffset: p.logprobs["text_offset"]
      },
      finishReason: p["finish_reason"]
    })),
    usage: {
      completionTokens: result.body.usage["completion_tokens"],
      promptTokens: result.body.usage["prompt_tokens"],
      totalTokens: result.body.usage["total_tokens"]
    }
  };
}
async function getCompletions(context, prompt, deploymentId, options = { requestOptions: {} }) {
  const result = await _getCompletionsSend(context, prompt, deploymentId, options);
  return _getCompletionsDeserialize(result);
}
function _getChatCompletionsSend(context, messages, deploymentId, options = { requestOptions: {} }) {
  var _a2, _b, _c;
  return context.path("/deployments/{deploymentId}/chat/completions", deploymentId).post({
    allowInsecureConnection: (_a2 = options.requestOptions) === null || _a2 === void 0 ? void 0 : _a2.allowInsecureConnection,
    skipUrlEncoding: (_b = options.requestOptions) === null || _b === void 0 ? void 0 : _b.skipUrlEncoding,
    headers: Object.assign({}, (_c = options.requestOptions) === null || _c === void 0 ? void 0 : _c.headers),
    body: {
      messages,
      max_tokens: options === null || options === void 0 ? void 0 : options.maxTokens,
      temperature: options === null || options === void 0 ? void 0 : options.temperature,
      top_p: options === null || options === void 0 ? void 0 : options.topP,
      logit_bias: options === null || options === void 0 ? void 0 : options.logitBias,
      user: options === null || options === void 0 ? void 0 : options.user,
      n: options === null || options === void 0 ? void 0 : options.n,
      stop: options === null || options === void 0 ? void 0 : options.stop,
      presence_penalty: options === null || options === void 0 ? void 0 : options.presencePenalty,
      frequency_penalty: options === null || options === void 0 ? void 0 : options.frequencyPenalty,
      stream: options === null || options === void 0 ? void 0 : options.stream,
      model: options === null || options === void 0 ? void 0 : options.model
    }
  });
}
async function _getChatCompletionsDeserialize(result) {
  var _a2;
  if (isUnexpected(result)) {
    throw result.body;
  }
  return {
    id: result.body["id"],
    created: result.body["created"],
    choices: ((_a2 = result.body["choices"]) !== null && _a2 !== void 0 ? _a2 : []).map((p) => {
      var _a3, _b, _c, _d;
      return {
        message: !p.message ? void 0 : { role: (_a3 = p.message) === null || _a3 === void 0 ? void 0 : _a3["role"], content: (_b = p.message) === null || _b === void 0 ? void 0 : _b["content"] },
        index: p["index"],
        finishReason: p["finish_reason"],
        delta: !p.delta ? void 0 : { role: (_c = p.delta) === null || _c === void 0 ? void 0 : _c["role"], content: (_d = p.delta) === null || _d === void 0 ? void 0 : _d["content"] }
      };
    }),
    usage: {
      completionTokens: result.body.usage["completion_tokens"],
      promptTokens: result.body.usage["prompt_tokens"],
      totalTokens: result.body.usage["total_tokens"]
    }
  };
}
async function getChatCompletions(context, messages, deploymentId, options = { requestOptions: {} }) {
  const result = await _getChatCompletionsSend(context, messages, deploymentId, options);
  return _getChatCompletionsDeserialize(result);
}
function getCompletionsResult(body) {
  var _a2;
  return {
    id: body["id"],
    created: body["created"],
    choices: ((_a2 = body["choices"]) !== null && _a2 !== void 0 ? _a2 : []).map((p) => ({
      text: p["text"],
      index: p["index"],
      logprobs: p.logprobs === null ? null : {
        tokens: p.logprobs["tokens"],
        tokenLogprobs: p.logprobs["token_logprobs"],
        topLogprobs: p.logprobs["top_logprobs"],
        textOffset: p.logprobs["text_offset"]
      },
      finishReason: p["finish_reason"]
    }))
  };
}
function getChatCompletionsResult(body) {
  var _a2;
  return {
    id: body["id"],
    created: body["created"],
    choices: ((_a2 = body["choices"]) !== null && _a2 !== void 0 ? _a2 : []).map((p) => {
      var _a3, _b, _c, _d;
      return {
        message: !p.message ? void 0 : { role: (_a3 = p.message) === null || _a3 === void 0 ? void 0 : _a3["role"], content: (_b = p.message) === null || _b === void 0 ? void 0 : _b["content"] },
        index: p["index"],
        finishReason: p["finish_reason"],
        delta: !p.delta ? void 0 : { role: (_c = p.delta) === null || _c === void 0 ? void 0 : _c["role"], content: (_d = p.delta) === null || _d === void 0 ? void 0 : _d["content"] }
      };
    })
  };
}

// node_modules/@azure/openai/dist-esm/src/api/getStream.browser.js
function getStream(response) {
  return __asyncGenerator(this, arguments, function* getStream_1() {
    const stream = (yield __await(response.asBrowserStream())).body;
    if (!stream)
      throw new Error("No stream found in response. Did you enable the stream option?");
    const encoder = new TextDecoder();
    const reader = stream.getReader();
    while (true) {
      const { value, done } = yield __await(reader.read());
      if (done) {
        break;
      }
      yield yield __await(encoder.decode(value));
    }
  });
}

// node_modules/@azure/openai/dist-esm/src/api/sse.js
async function getSSEs(response, toEvent) {
  const stream = getStream(response);
  let prevLineIfIncomplete = "";
  let started = false;
  return streamToEvents(stream, (chunk) => {
    if (!chunk.startsWith("data: ") && !started) {
      throw new Error(chunk);
    }
    started = true;
    const events = [];
    for (let str of chunk.split("\n\n")) {
      if (str.startsWith("data: ")) {
        str = str.slice(6);
      }
      if (["", "[DONE]", "[DONE]\n"].includes(str)) {
        return events;
      }
      try {
        const event = JSON.parse(prevLineIfIncomplete + str);
        prevLineIfIncomplete = "";
        events.push(toEvent(event));
      } catch (e) {
        prevLineIfIncomplete += str;
      }
    }
    return events;
  });
}
function streamToEvents(stream, processChunk) {
  return __asyncGenerator(this, arguments, function* streamToEvents_1() {
    var _a2, e_1, _b, _c;
    try {
      for (var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a2 = stream_1_1.done, !_a2; ) {
        _c = stream_1_1.value;
        _d = false;
        try {
          const chunk = _c;
          yield __await(yield* __asyncDelegator(__asyncValues(processChunk(chunk))));
        } finally {
          _d = true;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_d && !_a2 && (_b = stream_1.return))
          yield __await(_b.call(stream_1));
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  });
}

// node_modules/@azure/openai/dist-esm/src/OpenAIClient.js
var OpenAIClient = class {
  constructor(endpointOrOpenAiKey, credOrOptions = {}, options = {}) {
    var _a2, _b;
    this._isAzure = false;
    let opts;
    let endpoint;
    let cred;
    if (isCred(credOrOptions)) {
      endpoint = endpointOrOpenAiKey;
      cred = credOrOptions;
      opts = options;
      this._isAzure = true;
    } else {
      endpoint = createOpenAIEndpoint(1);
      cred = endpointOrOpenAiKey;
      const { credentials } = credOrOptions, restOpts = __rest(credOrOptions, ["credentials"]);
      opts = Object.assign({ credentials: {
        apiKeyHeaderName: (_a2 = credentials === null || credentials === void 0 ? void 0 : credentials.apiKeyHeaderName) !== null && _a2 !== void 0 ? _a2 : "Authorization",
        scopes: credentials === null || credentials === void 0 ? void 0 : credentials.scopes
      } }, restOpts);
    }
    this._client = createOpenAI(endpoint, cred, Object.assign(Object.assign({}, opts), this._isAzure ? {} : {
      additionalPolicies: [
        ...(_b = opts.additionalPolicies) !== null && _b !== void 0 ? _b : [],
        {
          position: "perCall",
          policy: {
            name: "openAiEndpoint",
            sendRequest: (request, next) => {
              const obj = new URL(request.url);
              const parts = obj.pathname.split("/");
              obj.pathname = `/${parts[1]}/${parts.slice(5).join("/")}`;
              obj.searchParams.delete("api-version");
              request.url = obj.toString();
              return next(request);
            }
          }
        }
      ]
    }));
  }
  /**
   * Returns textual completions as configured for a given prompt.
   * @param deploymentOrModelName - Specifies either the model deployment name (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param prompt - The prompt to use for this request.
   * @param options - The options for this completions request.
   * @returns The completions for the given prompt.
   */
  getCompletions(deploymentOrModelName, prompt, options = { requestOptions: {} }) {
    this.setModel(deploymentOrModelName, options);
    return getCompletions(this._client, prompt, deploymentOrModelName, options);
  }
  /**
   * Lists the completions tokens as they become available for a given prompt.
   * @param deploymentOrModelName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param prompt - The prompt to use for this request.
   * @param options - The completions options for this completions request.
   * @returns An asynchronous iterable of completions tokens.
   */
  /**
   * Lists the completions tokens as they become available for a given prompt.
   * @param deploymentOrModelName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param prompt - The prompt to use for this request.
   * @param options - The completions options for this completions request.
   * @returns An asynchronous iterable of completions tokens.
   */
  listCompletions(deploymentOrModelName, prompt, options = {}) {
    this.setModel(deploymentOrModelName, options);
    const response = _getCompletionsSend(this._client, prompt, deploymentOrModelName, Object.assign(Object.assign({}, options), { stream: true }));
    return getSSEs(response, getCompletionsResult);
  }
  /**
   * Return the computed embeddings for a given prompt.
   * @param deploymentOrModelName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param input - The prompt to use for this request.
   * @param options - The embeddings options for this embeddings request.
   * @returns The embeddings for the given prompt.
   */
  getEmbeddings(deploymentOrModelName, input, options = { requestOptions: {} }) {
    this.setModel(deploymentOrModelName, options);
    return getEmbeddings(this._client, input, deploymentOrModelName, options);
  }
  /**
   * Get chat completions for provided chat context messages.
   * @param deploymentOrModelName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param messages - The chat context messages to use for this request.
   * @param options - The chat completions options for this completions request.
   * @returns The chat completions for the given chat context messages.
   */
  getChatCompletions(deploymentOrModelName, messages, options = { requestOptions: {} }) {
    this.setModel(deploymentOrModelName, options);
    return getChatCompletions(this._client, messages, deploymentOrModelName, options);
  }
  /**
   * Lists the chat completions tokens as they become available for a chat context.
   * @param deploymentOrModelName - The name of the model deployment (when using Azure OpenAI) or model name (when using non-Azure OpenAI) to use for this request.
   * @param messages - The chat context messages to use for this request.
   * @param options - The chat completions options for this chat completions request.
   * @returns An asynchronous iterable of chat completions tokens.
   */
  listChatCompletions(deploymentOrModelName, messages, options = { requestOptions: {} }) {
    this.setModel(deploymentOrModelName, options);
    const response = _getChatCompletionsSend(this._client, messages, deploymentOrModelName, Object.assign(Object.assign({}, options), { stream: true }));
    return getSSEs(response, getChatCompletionsResult);
  }
  setModel(model, options) {
    if (!this._isAzure) {
      options.model = model;
    }
  }
};
function createOpenAIEndpoint(version) {
  return `https://api.openai.com/v${version}`;
}
function isCred(cred) {
  return isTokenCredential(cred) || cred.key !== void 0;
}

// node_modules/@azure/openai/dist-esm/src/OpenAIKeyCredential.js
var OpenAIKeyCredential = class {
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = createKey(key);
  }
  /**
   * The value of the key to be used in authentication
   */
  get key() {
    return this._key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  update(newKey) {
    this._key = createKey(newKey);
  }
};
function createKey(key) {
  return key.startsWith("Bearer ") ? key : `Bearer ${key}`;
}
export {
  AzureKeyCredential,
  OpenAIClient,
  OpenAIKeyCredential
};
//# sourceMappingURL=@azure_openai.js.map
